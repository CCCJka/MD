# 计算机组成

##### CPU最主要的组成：

+ ALU:计算单元
+ PC:程序计数器
+ Registers:寄存器





### 进程、线程

同一个进程内部：有多个任务并发执行的需求（比如，一边计算，一边接收网络数据，一边刷新界面）

能不能用多进程？可以，但是问题多，最严重的问题是容易杀死别的进程

线程的概念：共享空间，不共享计算

进程是静态的概念：程序进入内存，分配相对应的资源：内存空间，进程进入内存，同时产生一个主线程

线程是保存上下文，保存现场

线程是动态的概念：是可执行的计算单元（任务）

一个**ALU**同一时间智能执行一个线程

​		对于一个程序，设置都少个线程合适？		有一个公式可以计算：

![image-20230309155353424](C:\Users\Insummer\Desktop\markdown\进程线程\线程公式.png)

### CPU的速度和内存的速度

（100：1）这里的速度指的是ALU访问寄存器的速度比访问内存的速度为100倍

可以不用载入到内存，直接放入到寄存器中计算，但是这需要大量寄存器，所以用内存是为了性价比考虑

为了充分利用CPU的计算能力，在CPU和内存之间架设了缓存的概念。缓存是一个独立的物理设备

CPU到内存有三级缓存

**缓存行**：一次性读取的数据块

程序的局部性原理：空间局部性、时间局部性

如果缓存行大：命中率高，但是读取效率低。

如果缓存行小：命中率低，但是读取效率高。

目前的计算机多采用64Byte（64 * 8bit）为一行

由于缓存行的存在，需要有一种机制来保证缓存数据的一致性，这种机制被称为缓存行的数据一致性。

CPU不一定按照指令执行操作，有可能是乱序执行。那么为什么会乱序执行呢？主要是为了提高效率，在等待指令的时候优先执行后面的语句。

#### 单线程的as-if-serial

单个线程两条语句，未必是按顺序执行。

单个线程的重排序，必须保证最终一致性

as-if-serial：看上去像序列化（单线程）

#### CPU乱序可能会产生的后果

多线程可能会产生不希望看到的结果

ThisEscape（This溢出问题）

#### 上锁

synchronized关键字

```java
/*业务逻辑：
		第一次判断INSTANCE是否为空，如果为空将上锁，上完锁后再判断一次是否为空，如果依然为空则说明再上锁过程中没有别的线程将它new出来，那么则new一个实例
		但是第二次和第一次是同时运行的，因为是多线程，第一次判断为空，然后暂停让第二个线程判断，第二个线程判断也为空，继续运行下去，然后第二次判断依然为空，接着创建一个实例，完成后第一次线程继续运行，判断INSTANCE不为空，则不创建新的实例，减少了多次创建单例导致的访问内容不一致，并且加快了单例的速度，加快运行速度
*/
public static 类名 getInstance(){
    if(INSTANCE == null){		//双重检查
        synchronized(类名.class){
            if(INSTANCE == null){
                try{
                    Thread.sleep(1);
                }catch(InterruptedException e){
                    e.pintStackTrace();
                }
                INSTANCE = new 类名();
            }
        }
    }
    return INSTANCE;
}
```



#### JVM的内存屏障

使用volatile添加屏障：

​							可以保障可见性。

​							禁止重排序。

